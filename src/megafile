/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ituriel <ituriel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 14:06:00 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/17 18:35:47 by ituriel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

# ifndef MINISHELL_H
# define MINISHELL_H

#define _POSIX_C_SOURCE 200809L
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <dirent.h>
#include <termios.h>
#include <curses.h>
#include <term.h>
#include <readline/readline.h>
#include <readline/history.h>
#include <signal.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include "../libft/libft.h"
#include "../libft/ft_printf/ft_printf.h"
#include <signal.h>
#include <errno.h>

// Global used for signals
extern int  g_sig;
extern int   g_loop_id;



// Environment variable structure
typedef struct  s_envp
{
    char    *key;
    char    **values;
}   t_envp;

// Doubly-linked list of environments
typedef struct s_envi
{
    t_envp      *env;
    struct s_envi   *prev;
    struct s_envi   *next;
}   t_envi;

// AST node for commands and operators
typedef struct s_tree
{
    char    *content;
    struct s_tree   *left;
    struct s_tree   *right;
    int heredoc_fd;
    int start;
    int end;
}   t_tree;

// Execution context structure
typedef struct s_exec
{
    char    **argv;
    int status;
    t_envi  *env;
    t_tree  *ast;
}   t_exec;

// global memory structure
typedef struct s_memory
{
    t_envi *envi;
    t_tree *tree;
    t_exec *exec;
    char *line;
    char **tokens;
    int status;
}   t_memory;

// init_env
void    env_init(t_envi **shell, char **envp);
void shell_envi_init(t_memory **shell, char **envp);
void    env_destroy(t_envi *shell);

// memory
void    ft_free_string_array(char **arr);
void ft_free_shell(t_memory **shell);

// prompt
char    *prompt_read_line(const char *prompt_fmt);

// tokenizer
char    **lexer_split_tokens(const char *input_line);

// parser
t_tree  *parser_build_ast(t_memory **shell);
void    parser_free_ast(t_tree *root);
int is_pipe(char *s);
int is_redirect(char *s);
t_tree  *new_node(const char *content);
t_tree  *make_command_node(char **tokens, int start, int end);

// executor
int executor_execute_ast(t_tree *node, t_memory **shell);
int executor_is_builtin(const char *command_name);
int executor_run_builtin(t_exec *context, t_memory **shell);
int exec_pipe_node(t_memory **shell, t_tree *node);
int exec_redirect_node(t_tree *node, t_memory **shell);
int	get_heredoc_fd(char *delimiter, t_envi *env_list);

// builtins
int builtin_cd(t_exec *context);
int builtin_echo(t_exec *context);
int builtin_env(t_exec *context);
int builtin_export(t_exec *context);
int builtin_unset(t_exec *context);
int builtin_pwd(t_exec *context);
int	builtin_exit(t_exec *context, t_memory **shell);
int cd_add_env(t_envi **env_list, char *key, char *value);

// utils
int  is_valid_name(const char *name);
char    *ft_mini_strndup(const char *src, size_t n);
char    *ft_triple_strjoin(const char *s1, const char *s2, const char *s3);
int ft_isspace(int c);
char    **env_list_to_array(t_envi *env);
char	*ft_strjoin_arr(char **arr, char sep);
char	**ft_strdup_arr(char **arr);
size_t	ft_arr_count(char **arr);

// path
char    *find_in_path(const char *cmd, t_envi *env_list);

// expansion
char    *expand_token(const char *token, t_envi *env_list, int last_status);
void	expand_tokens(t_memory **shell);
int	toggle_quotes(char c, int *in_single, int *in_double);

// signals
void    signal_init(void);

// prints
void    print_error(const char *msg);
void    print_message(const char *msg);

# endif



/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   prompt.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc <adi-marc@student.42luxembourg    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 14:52:36 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/08 18:27:15 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

// Checks if the string contains unclosed quotes
static int  has_unclosed_quotes(const char *s)
{
    int in_squote;
    int in_dquote;

    in_squote = 0;
    in_dquote = 0;
    while (*s)
    {
        if (*s == 39 && !in_dquote)
            in_squote = !in_squote;
        else if (*s == 34 && !in_squote)
            in_dquote = !in_dquote;
        s++;
    }
    return (in_squote || in_dquote);
}

// Prompt the user with > if unclosed quotes
static char *prompt_continue(char *prev)
{
    char    *cont;
    char    *joined;

    cont = readline("> ");
    if (!cont)
        return (prev);
    joined = ft_triple_strjoin(prev, "\n", cont);
    free(prev);
    free(cont);
    return (joined);
}

// Wait for user prompt and trim it if needed
char    *prompt_read_line(const char *prompt)
{
    char    *raw;
    char    *trimmed;

    raw = readline(prompt);
    if (!raw)
        return (NULL);
    while (has_unclosed_quotes(raw))
        raw = prompt_continue(raw);
    trimmed = ft_strtrim(raw, " \t\n");
    free(raw);
    if (*trimmed)
        add_history(trimmed);
    return (trimmed);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ituriel <ituriel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 15:48:26 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/17 18:40:46 by ituriel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

static int  exec_builtin_cmd(char **argv, t_memory **shell)
{
    t_envi **env_list;
    int result;

    env_list = &(*shell)->envi;
    (*shell)->exec = malloc(sizeof(t_exec));
    (*shell)->exec->argv = argv;
    (*shell)->exec->env = (*env_list);
    (*shell)->exec->status = 0;
    result = executor_run_builtin((*shell)->exec, shell);
    return (result);
}

// Note that WEXITSTATUS and WIFEXITED are not functions but macros
static int  exec_external_cmd(char **argv, t_memory **shell)
{
	char	**envp;
	char	*path;
	pid_t	pid;
	int		status;
    t_envi **env_list;

    env_list = &(*shell)->envi;
	pid = fork();
	if (pid < 0)
    {
        perror("fork");
        return(1);
    }
	if (pid == 0)
	{
		envp = env_list_to_array(*env_list);
		if (ft_strchr(argv[0], '/'))
			path = ft_strdup(argv[0]);
		else
			path = find_in_path(argv[0], *env_list);
		if (!path)
		{
			ft_printf("minishell: %s: command not found\n", argv[0]);
            ft_free_string_array(envp);
			exit(127);
		}
		execve(path, argv, envp);
		ft_printf("minishell: %s: %s\n", argv[0], strerror(errno));
		free(path);
		ft_free_string_array(envp);
		exit(126);
	}
	waitpid(pid, &status, 0);
	if (WIFEXITED(status))
		return (WEXITSTATUS(status));
	return (1);
}

static int  exec_simple_cmd(t_tree *node, t_memory **shell)
{
    char    **argv;

    argv = ft_split(node->content, ' ');
    if (!argv)
        return (1);
    if (executor_is_builtin(argv[0]))
        (*shell)->status = exec_builtin_cmd(argv, shell);
    else
        (*shell)->status = exec_external_cmd(argv, shell);
    ft_free_string_array(argv);
    return ((*shell)->status);
}

int executor_execute_ast(t_tree *node, t_memory **shell)
{    
    if (!node)
        return (0);
    if (is_pipe(node->content))
        return (exec_pipe_node(shell, node));
    if (is_redirect(node->content))
        return (exec_redirect_node(node, shell));
    return (exec_simple_cmd(node, shell));
}

int executor_is_builtin(const char *cmd)
{
    if (!cmd)
        return (0);
    return (!strcmp(cmd, "cd")
        || !strcmp(cmd, "echo")
        || !strcmp(cmd, "env")
        || !strcmp(cmd, "export")
        || !strcmp(cmd, "unset")
        || !strcmp(cmd, "pwd")
        || !strcmp(cmd, "exit"));
}

int executor_run_builtin(t_exec *context, t_memory **shell)
{
    if (!context || !context->argv || !context->argv[0])
        return (1);
    if (!strcmp(context->argv[0], "cd"))
        return (builtin_cd(context));
    if (!strcmp(context->argv[0], "echo"))
        return (builtin_echo(context));
    if (!strcmp(context->argv[0], "env"))
        return (builtin_env(context));
    if (!strcmp(context->argv[0], "export"))
        return (builtin_export(context));
    if (!strcmp(context->argv[0], "unset"))
        return (builtin_unset(context));
    if (!strcmp(context->argv[0], "pwd"))
        return (builtin_pwd(context));
    if (!strcmp(context->argv[0], "exit"))
        return (builtin_exit(context, shell));
    return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipe.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ituriel <ituriel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 16:12:44 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/17 18:41:03 by ituriel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

static pid_t    fork_pipe_child(int *fd, t_tree *node, t_memory **shell, int is_left)
{
    pid_t   pid;
    
    pid = fork();
    if (pid < 0)
        return (-1);
    if (pid == 0)
    {
        if (is_left)
        {
            close(fd[0]);
            if (dup2(fd[1], STDOUT_FILENO) < 0)
                exit(EXIT_FAILURE);
            close(fd[1]);
            executor_execute_ast(node->left, shell);
        }
        else
        {
            close(fd[1]);
            if (dup2(fd[0], STDIN_FILENO) < 0)
                exit(EXIT_FAILURE);
            close(fd[0]);
            executor_execute_ast(node->right, shell);
        }
        exit(EXIT_SUCCESS);
    }
    return (pid);
}

static int  fork_error(int *fd)
{
    print_error("minishell: fork failed\n");
    close(fd[0]);
    close(fd[1]);
    return (1);
}

static int  parent_waits(pid_t pid_left, pid_t pid_right, int *fd)
{
    int status;

    close(fd[0]);
    close(fd[1]);
    waitpid(pid_left, NULL, 0);
    waitpid(pid_right, &status, 0);
    if (WIFEXITED(status))
        return(WEXITSTATUS(status));
    return (1);
}

int exec_pipe_node(t_memory **shell, t_tree *node)
{
    int fd[2];
    pid_t   pid_left;
    pid_t   pid_right;

    if (pipe(fd) < 0)
    {
        print_error("minishell: pipe failed\n");
        return (1);
    }
    pid_left = fork_pipe_child(fd, node, shell, 1);
    if (pid_left < 0)
        return (fork_error(fd));
    pid_right = fork_pipe_child(fd, node, shell, 0);
    if (pid_right < 0)
        return(fork_error(fd));
    return (parent_waits(pid_left, pid_right, fd));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirect.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ituriel <ituriel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 16:28:35 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/17 18:41:42 by ituriel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

static int	redirect_out(t_tree *node,t_memory **shell, int flags);
static int	redirect_in(t_tree *node, t_memory **shell);
static int	redirect_heredoc(t_tree *node, t_memory **shell);

int exec_redirect_node(t_tree *node, t_memory **shell)
{
    if (!node || !node->content)
        return (1);
    if (ft_strcmp(node->content, ">") == 0)
        return (redirect_out(node, shell,
                            O_WRONLY | O_CREAT | O_TRUNC));
    if (ft_strcmp(node->content, ">>") == 0)
        return (redirect_out(node, shell,
                            O_WRONLY | O_CREAT | O_APPEND));
    if (ft_strcmp(node->content, "<") == 0)
            return (redirect_in(node, shell));
    if (ft_strcmp(node->content, "<<") == 0)
            return (redirect_heredoc(node, shell));
    return (1);
}

static void	restore_fd(int saved_fd, int target_fd)
{
	dup2(saved_fd, target_fd);
	close(saved_fd);
}

static int	redirect_out(t_tree *node,t_memory **shell, int flags)
{
	int	saved_stdout;
	int	file_fd;
	int	status;

	saved_stdout = dup(STDOUT_FILENO);
	if (saved_stdout < 0)
		return (1);
	file_fd = open(node->right->content, flags, 0644);
	if (file_fd < 0)
	{
		ft_printf("minishell: %s: %s\n",
			node->right->content, strerror(errno));
		close(saved_stdout);
		return (1);
	}
	if (dup2(file_fd, STDOUT_FILENO) < 0)
	{
		close(file_fd);
		ft_printf("minishell: %s\n", strerror(errno));
		dup2(saved_stdout, STDOUT_FILENO);
		close(saved_stdout);
		return (1);
	}
	close(file_fd);
	status = executor_execute_ast(node->left, shell);
	dup2(saved_stdout, STDOUT_FILENO);
	close(saved_stdout);
	return (status);
}

static int	redirect_in(t_tree *node, t_memory **shell)
{
	int	saved_stdin;
	int	read_fd;
	int	status;

	saved_stdin = dup(STDIN_FILENO);
	if (saved_stdin < 0)
		return (1);
	read_fd = open(node->right->content, O_RDONLY);
	if (read_fd < 0)
	{
		ft_printf("minishell: %s: %s\n",
			node->right->content, strerror(errno));
		close(saved_stdin);
		return (1);
	}
	if (dup2(read_fd, STDIN_FILENO) < 0)
	{
		close(read_fd);
		ft_printf("minishell: %s\n", strerror(errno));
		dup2(saved_stdin, STDIN_FILENO);
		close(saved_stdin);
		return (1);
	}
	close(read_fd);
	status = executor_execute_ast(node->left, shell);
	dup2(saved_stdin, STDIN_FILENO);
	close(saved_stdin);
	return (status);
}

static int	redirect_heredoc(t_tree *node, t_memory **shell)
{
	int	saved_stdin;
	int	heredoc_fd;
	int	status;
	t_envi **env_list;

	env_list = &(*shell)->envi;
	saved_stdin = dup(STDIN_FILENO);
	if (saved_stdin < 0)
		return (1);
	heredoc_fd = get_heredoc_fd(node->right->content, *env_list);
	if (heredoc_fd < 0)
	{
		restore_fd(saved_stdin, STDIN_FILENO);
		return (1);
	}
	if (dup2(heredoc_fd, STDIN_FILENO) < 0)
	{
		close(heredoc_fd);
		restore_fd(saved_stdin, STDIN_FILENO);
		return (1);
	}
	close(heredoc_fd);
	status = executor_execute_ast(node->left, shell);
	restore_fd(saved_stdin, STDIN_FILENO);
	return (status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc <adi-marc@student.42luxembourg    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 18:11:03 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/08 18:57:53 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

int g_sig;

static void handle_sigint(int signo)
{
    (void)signo;
    g_sig = 130;
    write(STDOUT_FILENO, "\n", 1);
    rl_on_new_line();
    rl_replace_line("", 0);
    rl_redisplay();
}

static void handle_sigquit(int signo)
{
    (void)signo;
}

void    signal_init(void)
{
    struct sigaction    sa;

    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = handle_sigint;
    sigaction(SIGINT, &sa, NULL);
    sa.sa_handler = handle_sigquit;
    sigaction(SIGQUIT, &sa, NULL);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenizer.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc <adi-marc@student.42luxembourg    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 15:02:48 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/08 15:22:03 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static int  is_special(char c)
{
    return (c == '|' || c == '<' || c == '>');
}

// Count the number of tokens to be extract
static size_t   count_tokens(const char *s)
{
    size_t  count;
    int in_sq;
    int in_dq;

    count = 0;
    in_sq = 0;
    in_dq = 0;
    while (*s)
    {
        while (*s && ft_isspace(*s))
            s++;
        if (!*s)
            break ;
        count++;
        if (!in_sq && !in_dq && is_special(*s))
        {
            if ((*s == '<' || *s == '>') && s[1] == *s)
                s += 2;
            else
                s++;
        }
        else
        {
            while (*s && (!ft_isspace(*s) || in_sq || in_dq))
            {
                if (!in_sq && *s == 34)
                    in_dq = !in_dq;
                else if (!in_dq && *s == 39)
                    in_sq = !in_sq;
                else if (!in_sq && !in_dq && is_special(*s))
                    break ;
                s++;
            }
        }
    }
    return (count);
}

// Extract the next token into a malloc buffer
static char *next_token(const char **sp)
{
    const char  *start;
    const char  *s;
    char    *buf;
    size_t  len;
    int in_sq;
    int in_dq;
    
    len = 0;
    in_sq = 0;
    in_dq = 0;
    s = *sp;
    while(ft_isspace(*s))
        s++;
    start = s;
    if (!in_sq && !in_dq && is_special(*s))
    {
        if ((s[0] == '<' || s[0] == '>') && s[1] == s[0])
            len = 2;
        else
            len = 1;
    }
    else
    {
        while (*s && (!ft_isspace(*s) || in_sq || in_dq))
        {
            if (!in_sq && *s == 34)
                in_dq = !in_dq;
            else if (!in_dq && *s == 39)
                in_sq = !in_sq;
            else if (!in_sq && !in_dq && is_special(*s))
                break ;
            s++;
        }
        len = s - start;
    }
    
    buf = malloc(len + 1);
    if (!buf)
        return (NULL);
    ft_strlcpy(buf, start, len + 1);
    *sp = start + len;
    return (buf);
}

char    **lexer_split_tokens(const char *input_line)
{
    size_t  n;
    size_t  i;
    char    **tokens;
    const char  *p;

    n = count_tokens(input_line);
    i = 0;
    tokens = malloc(sizeof(*tokens) * (n + 1));
    p = input_line;
    if (!tokens)
        return (NULL);
    while (i < n)
        tokens[i++] = next_token(&p);
    tokens[i] = NULL;
    return (tokens);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ituriel <ituriel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 15:24:00 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/17 18:32:13 by ituriel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

static t_tree   *parse_range(char **tokens, int start, int end);
static int  find_token(char **tokens, int start, int end,
                        int (*checker)(char *));

t_tree  *parser_build_ast(t_memory **shell)
{
    int count;
    char **tokens;

    tokens = (*shell)->tokens;

    count = 0;
    while (tokens[count])
        count++;
    if (count == 0)
        return (NULL);
    return (parse_range(tokens, 0, count - 1));
}

static t_tree   *parse_range(char **tokens, int start, int end)
{
    int i;
    t_tree  *node;

    if (start > end)
        return (NULL);
    i = find_token(tokens, start, end, is_pipe);
    while (i >= 0)
    {
        node = new_node(tokens[i]);
         if (!node)
            return(NULL);
        node->left = parse_range(tokens, start, i - 1);
        node->right = parse_range(tokens, i + 1, end);
        if ((start < i && !node->left) || (i + 1 <= end && !node->right))
        {
            parser_free_ast(node);
            return (NULL);
        }
        return (node);
    }
    i = find_token(tokens, start, end, is_redirect);
    if (i >= 0)
    {
        node = new_node(tokens[i]);
        if (!node)
            return (NULL);
        node->left = parse_range(tokens, start, i - 1);
        node->right = parse_range(tokens, i + 1, end);
        if ((start < i && !node->left) || (i + 1 <= end && !node->right))
        {
            parser_free_ast(node);
            return (NULL);
        }
        return (node);
    }
    return (make_command_node(tokens, start, end));
}

static int  find_token(char **tokens, int start, int end,
                        int (*checker)(char *))
{
    int i;

    i = end;
    while (i >= start)
    {
        if (checker(tokens[i]))
            return (i);
        i--;
    }
    return (-1);
}

void    parser_free_ast(t_tree *node)
{
    if (!node)
        return;
printf("[LOOP %d][AST DEBUG] free start: node(%s) @ %p left=%p right=%p\n",
           g_loop_id,
           node->content,
           (void*)node,
           (void*)node->left,
           (void*)node->right);
    parser_free_ast(node->left);
    parser_free_ast(node->right);
    printf("[LOOP %d][AST DEBUG] free content: \"%s\" @ %p\n",
           g_loop_id, node->content, (void*)node->content);
    if (node->content)
    {
        free(node->content);
        node->content = NULL;
    }
    printf("[LOOP %d][AST DEBUG] free node @ %p\n",
           g_loop_id, (void*)node);
    free(node);
    node = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ituriel <ituriel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 15:36:32 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/17 15:46:05 by ituriel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

int token_count(char **tokens)
{
    int i;

    i = 0;
    while (tokens[i])
        i++;
    return (i);
}

t_tree  *new_node(const char *content)
{
    t_tree  *node;

    node = malloc(sizeof(t_tree) * 1);
    if (!node)
	{
        return (NULL);
	}
	node->content = ft_strdup(content);
	fprintf(stderr, "[DBG] new_node alloc @%p for \"%s\"\n", node, content);
	if (!node->content)
	{
		free(node);
		return (NULL);
	}
	node->left = NULL;
    node->right = NULL;
    node->heredoc_fd = -1;
    node->start = -1;
    node->end = -1;
	printf("[LOOP %d][AST] new_node(%s) @ %p\n",g_loop_id, content, (void*)node);
	return (node);
}

t_tree	*make_command_node(char **tokens, int start, int end)
{
	int		total_len;
	int		i;
	char	*buf;
	t_tree	*node;

	total_len = 0;
	i = start;
	while (i <= end)
	{
		total_len += ft_strlen(tokens[i]) + 1;
		i++;
	}
	buf = malloc(total_len);
	if (!buf)
		return (NULL);
	buf[0] = '\0';
	i = start;
	while (i <= end)
	{
		ft_strlcat(buf, tokens[i], total_len);
		if (i < end)
			ft_strlcat(buf, " ", total_len);
		i++;
	}
	node = new_node(buf);
	free(buf);
	return (node);
}

int is_pipe(char *s)
{
    return (s && s[0] == '|' && !s[1]);
}

int is_redirect(char *s)
{
    return (s && (
        !ft_strcmp(s, "<") || !ft_strcmp(s, ">") ||
        !ft_strcmp(s, "<<") || !ft_strcmp(s, ">>")
    ));
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ituriel <ituriel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 14:05:57 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/17 18:36:34 by ituriel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

int   g_loop_id = 0;

int main(int argc, char **argv, char **envp)
{
    t_memory *shell;
    int status;

    (void)argc;
    (void)argv;
    signal_init();
    status = 0;
    shell_envi_init(&shell, envp);
    while (1)
    {
        g_loop_id++;
        printf("\n[LOOP %d] start\n", g_loop_id);
        shell->line = prompt_read_line("minishell$ ");
        if(!shell->line)
            break ;
        shell->tokens = lexer_split_tokens(shell->line);
        if (shell->tokens)
        {
            expand_tokens(&shell);
            shell->tree = parser_build_ast(&shell);
            ft_free_string_array(shell->tokens);
            if (shell->tree)
            {
                shell->status = executor_execute_ast(shell->tree, &shell);
                parser_free_ast(shell->tree);
            }
        }
        free(shell->line);
        shell->line = NULL;
    }
    status = shell->status;
    ft_free_shell(&shell);
    rl_clear_history();
    return (status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   memory.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ituriel <ituriel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 14:48:56 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/17 18:13:42 by ituriel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

// free an array of strings and the array itself
void    ft_free_string_array(char **arr)
{
    int i;

    if (!arr)
        return ;
    i = 0;
    while (arr[i])
    {
        free(arr[i]);
        i++;
    }
    free(arr);
    arr = NULL;
}

void ft_free_shell(t_memory **shell)
{
    if ((*shell)->envi)
    {
        env_destroy((*shell)->envi);
        (*shell)->envi = NULL;
    }
    if ((*shell)->tree)
    {
        parser_free_ast((*shell)->tree);
        (*shell)->tree = NULL;
    }
    if ((*shell)->exec)
    {
        if ((*shell)->exec->argv)
            ft_free_string_array((*shell)->exec->argv);
        (*shell)->exec->env = NULL;
        (*shell)->exec->ast = NULL;
        free((*shell)->exec);
        (*shell)->exec = NULL;
    }
    if ((*shell)->line)
    {
        free((*shell)->line);
        (*shell)->line = NULL;
    }
    if ((*shell)->tokens)
        ft_free_string_array((*shell)->tokens);
    free(*shell);
    *shell = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expansions_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc < adi-marc@student.42luxembour    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/10 11:25:28 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/10 11:29:06 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

int	toggle_quotes(char c, int *in_single, int *in_double)
{
	if (c == '\'' && !*in_double)
	{
		*in_single = !*in_single;
		return (1);
	}
	if (c == '"' && !*in_single)
	{
		*in_double = !*in_double;
		return (1);
	}
	return (0);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expansions.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ituriel <ituriel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/09 12:56:24 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/17 16:51:39 by ituriel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

static char	*get_env_str(char *key, t_envi *env_list)
{
	t_envi	*current;

	current = env_list;
	while (current)
	{
		if (!ft_strcmp(current->env->key, key)
			&& current->env->values && current->env->values[0])
			return (ft_strdup(current->env->values[0]));
		current = current->next;
	}
	return (ft_strdup(""));
}

static char *append_str(char *origin, char *to_add)
{
	char *joined;

    if (!origin)
        return to_add;     // just return fragment, don’t strdup()
    joined = ft_strjoin(origin, to_add);
    free(origin);
    free(to_add);
    return joined;
}

static char	*handle_dollar(const char **cursor, t_envi *env_list,
							int last_status)
{
	const char	*start;
	char		*key_str;
	char		*expansion;
	char		*status_str;

	if ((*cursor)[1] == '?')
	{
		status_str = ft_itoa(last_status);
		expansion = ft_strdup(status_str);
		free(status_str);
		*cursor += 2;
		return (expansion);
	}
	if (ft_isalpha((*cursor)[1]) || (*cursor)[1] == '_')
	{
		*cursor += 1;
		start = *cursor;
		while (ft_isalnum(**cursor) || **cursor == '_')
			(*cursor)++;
		key_str = ft_mini_strndup(start, *cursor - start);
		expansion = get_env_str(key_str, env_list);
		free(key_str);
		return (expansion);
	}
	/* lone '$' */
	*cursor += 1;
	return (ft_strdup("$"));
}

char	*expand_token(const char *token, t_envi *env_list, int last_status)
{
	const char	*cursor;
	char		*result;
	char		*fragment;
	int			in_single;
	int			in_double;

	cursor    = token;
	result    = NULL;
	in_single = 0;
	in_double = 0;
	while (*cursor)
	{
		if (toggle_quotes(*cursor, &in_single, &in_double))
		{
			cursor++;
			continue;
		}
		if (*cursor == '$' && !in_single && cursor[1] != '\0')
			fragment = handle_dollar(&cursor, env_list, last_status);
		else
		{
			fragment = ft_mini_strndup(cursor, 1);
			cursor++;
		}
		result = append_str(result, fragment);
	}
	return (result);
}

void	expand_tokens(t_memory **shell)
{
	int		index;
	char	*expanded;
	char **tokens;
	t_envi *env_list;
	int last_status;

	tokens = (*shell)->tokens;
	env_list = (*shell)->envi;
	last_status = (*shell)->status;
	index = 0;
	while (tokens[index])
	{
		expanded = expand_token(tokens[index], env_list, last_status);
		free(tokens[index]);
		tokens[index] = expanded;
		index++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   str_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc <adi-marc@student.42luxembourg    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:55:30 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/08 19:00:07 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

char    *ft_triple_strjoin(const char *s1, const char *s2, const char *s3)
{
    char    *res;
    size_t  len_one;
    size_t  len_two;
    size_t  len_three;
    size_t  i;

    len_one = ft_strlen(s1);
    len_two = ft_strlen(s2);
    len_three = ft_strlen(s3);
    res = malloc(sizeof(char) * (len_one + len_two + len_three) + 1);
    if (!res)
        return (NULL);
    i = 0;
    while (*s1)
        res[i++] = *s1++;
    while (*s2)
        res[i++] = *s2++;
    while (*s3)
        res[i++] = *s3++;
    res[i] = '\0';
    return (res);
}

char    *ft_mini_strndup(const char *src, size_t n)
{
    char    *dup;
    size_t  i;

    dup = malloc(sizeof(char) * n + 1);
    if (!dup)
        return (NULL);
    i = 0;
    while (i < n && src[i])
    {
        dup[i] = src[i];
        i++;
    }
    dup[i] = '\0';
    return (dup);
}

int ft_isspace(int c)
{
    return (c == ' ' || (c >= '\t' && c <= '\r'));
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strj_arr.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc <adi-marc@student.42luxembourg    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 18:52:01 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/08 18:56:13 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

size_t	ft_arr_count(char **arr)
{
	size_t	i;

	i = 0;
	while (arr[i])
		i++;
	return (i);
}

static size_t	ft_arr_strlen(char **arr)
{
	size_t	i;
	size_t	len;

	i = 0;
	len = 0;
	while (arr[i])
	{
		len += ft_strlen(arr[i]);
		i++;
	}
	return (len);
}

static void	ft_arr_fill(char **arr, char sep, char *dst)
{
	size_t	i;

	i = 0;
	while (arr[i])
	{
		ft_strlcpy(dst, arr[i], ft_strlen(arr[i]) + 1);
		dst += ft_strlen(arr[i]);
		if (arr[i + 1])
			*dst++ = sep;
		i++;
	}
	*dst = '\0';
}

char	*ft_strjoin_arr(char **arr, char sep)
{
	size_t	count;
	size_t	total;
	char	*res;

	count = ft_arr_count(arr);
	total = ft_arr_strlen(arr);
	if (count > 1)
		total += count - 1;
	res = malloc(total + 1);
	if (!res)
		return (NULL);
	ft_arr_fill(arr, sep, res);
	return (res);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc <adi-marc@student.42luxembourg    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:59:44 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/08 18:56:40 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

static  size_t  get_env_count(t_envi *env)
{
    size_t  count;

    count = 0;
    while(env)
    {
        count++;
        env = env->next;
    }
    return (count);
}

static char *make_env_entry(t_envi *node)
{
    char    *tmp;
    char    *entry;

    tmp = ft_strjoin_arr(node->env->values, ':');
    if (!tmp)
        return (NULL);
    entry = ft_triple_strjoin(node->env->key, "=", tmp);
    free(tmp);
    return (entry);
}

char    **env_list_to_array(t_envi *env)
{
    char **arr;
    char    *entry;
    size_t  len;
    size_t  i;

    len = get_env_count(env);
    arr = malloc(sizeof *arr * (len + 1));
    if (!arr)
        return (NULL);
    i = 0;
    while (env)
    {
        entry = make_env_entry(env);
        if (!entry)
            break ;
        arr[i++] = entry;
        env = env->next;
    }
    arr[i] = NULL;
    return (arr);
}

t_envi  *duplicate_env_list(t_envi *env)
{
    t_envi *copy;
    t_envi  *curr;

    copy = NULL;
    while (env)
    {
        curr = malloc(sizeof *curr);
        if (!curr)
            return (NULL);
        curr->env = malloc(sizeof *curr->env);
        if (!curr->env)
            return (NULL);
        curr->env->key = ft_strdup(env->env->key);
        curr->env->values = ft_strdup_arr(env->env->values);
        curr->prev = NULL;
        curr->next = copy;
        if (copy)
            copy->prev = curr;
        copy = curr;
        env = env->next;
    }
    return (copy);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   errors.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc <adi-marc@student.42luxembourg    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:52:21 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/08 17:53:39 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

void    print_error(const char *msg)
{
    while(*msg)
    {
        write(STDERR_FILENO, msg, 1);
        msg++;
    }
}

void    print_message(const char *msg)
{
    while (*msg)
    {
        write(STDOUT_FILENO, msg, 1);
        msg++;
    }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup_arr.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc <adi-marc@student.42luxembourg    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 18:54:58 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/08 18:55:15 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

static void	ft_free_dup(char **dup, size_t filled)
{
	while (filled--)
		free(dup[filled]);
	free(dup);
}

static int	ft_arr_dup_strs(char **arr, char **dup, size_t count)
{
	size_t	i;

	i = 0;
	while (i < count)
	{
		dup[i] = ft_strdup(arr[i]);
		if (!dup[i])
		{
			ft_free_dup(dup, i);
			return (0);
		}
		i++;
	}
	return (1);
}

char	**ft_strdup_arr(char **arr)
{
	size_t	count;
	char	**dup;

	count = ft_arr_count(arr);
	dup = malloc((count + 1) * sizeof(char *));
	if (!dup)
		return (NULL);
	if (!ft_arr_dup_strs(arr, dup, count))
		return (NULL);
	dup[count] = NULL;
	return (dup);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc <adi-marc@student.42luxembourg    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 18:42:55 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/09 13:44:59 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

static char	*heredoc_tmpfile(void)
{
	char	*prefix;
	char	*pid_str;
	char	*path;
	size_t	total_len;

	prefix = "/tmp/minishell_heredoc_";
	pid_str = ft_itoa(getpid());
	if (!pid_str)
		return (NULL);
	total_len = ft_strlen(prefix) + ft_strlen(pid_str) + 1;
	path = malloc(total_len);
	if (!path)
	{
		free(pid_str);
		return (NULL);
	}
	ft_strlcpy(path, prefix, total_len);
	ft_strlcat(path, pid_str, total_len);
	free(pid_str);
	return (path);
}

static void	write_heredoc_content(int write_fd, char *delimiter,
									t_envi *env_list)
{
	char	*line;
	char	*expanded;

	while (1)
	{
		line = readline("> ");
		if (!line)
			break ;
		if (ft_strcmp(line, delimiter) == 0)
		{
			free(line);
			break ;
		}
		/* expand $VAR inside the heredoc line */
		expanded = expand_token(line, env_list, 0);
		free(line);
		write(write_fd, expanded, ft_strlen(expanded));
		write(write_fd, "\n", 1);
		free(expanded);
	}
}

int	get_heredoc_fd(char *delimiter, t_envi *env_list)
{
	char	*tmpfile;
	int		write_fd;
	int		read_fd;

	tmpfile = heredoc_tmpfile();
	if (!tmpfile)
		return (-1);
	write_fd = open(tmpfile, O_CREAT | O_WRONLY | O_TRUNC, 0600);
	if (write_fd < 0)
	{
		free(tmpfile);
		return (-1);
	}
	write_heredoc_content(write_fd, delimiter, env_list);
	close(write_fd);
	read_fd = open(tmpfile, O_RDONLY);
	unlink(tmpfile);
	free(tmpfile);
	return (read_fd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   path_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc <adi-marc@student.42luxembourg    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 19:06:11 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/08 19:12:58 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

char    *find_in_path(const char *cmd, t_envi *env_list)
{
    t_envi  *node;
    char    *path_val;
    char    **dirs;
    size_t  i;

    node = env_list;
    while (node && ft_strcmp(node->env->key, "PATH"))
        node = node->next;
    if (!node || !node->env->values)
        return (NULL);
    dirs = node->env->values;
    i = 0;
    while (dirs[i])
    {
        path_val = ft_triple_strjoin(dirs[i], "/", cmd);
        if(!path_val)
            return (NULL);
        if (access(path_val, X_OK) == 0)
            return (path_val);
        free(path_val);
        i++;
    }
    return (NULL);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ituriel <ituriel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:10:18 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/17 18:42:04 by ituriel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

static int  update_existing(t_envi **env_list, char *key, char **vals)
{
    t_envi *node;

    node = *env_list;
    while(node)
    {
        if (ft_strcmp(node->env->key, key) == 0)
        {
            ft_free_string_array(node->env->values);
            node->env->values = vals;
            free(key);
            return (1);
        }
        node = node->next;
    }
    return (0);
}

static int  prepend_node(t_envi **env_list, char *key, char **vals)
{
    t_envi *node;

    node = malloc(sizeof *node);
    if (!node)
        return (1);
    node->env = malloc(sizeof *node->env);
    if (!node->env)
    {
        free(node);
        return (1);
    }
    node->env->key = key;
    node->env->values = vals;
    node->prev = NULL;
    node->next = *env_list;
    if (*env_list)
        (*env_list)->prev = node;
    *env_list = node;
    return (0);
}

static int  prepare_key_vals(const char *arg, char **key, char ***vals)
{
    char	*delim;

	delim = ft_strchr(arg, '=');
	if (!delim)
		return (0);
	*key = ft_mini_strndup(arg, delim - arg);
	if (!*key)
		return (1);
	if (!is_valid_name(*key))
	{
		ft_printf("minishell: export: `%s': not a valid identifier\n", *key);
		free(*key);
		return (-1);
	}
	*vals = ft_split(delim + 1, ':');
	if (!*vals)
	{
		free(*key);
		return (1);
	}
	return (2);
}

int add_or_update(t_envi **env_list, const char *arg)
{
    char *key;
    char    **vals;
    int status;

    status = prepare_key_vals(arg, &key, &vals);
    if (status == 0)
        return (0);
    if (status == 1 || status == -1)
        return (1);
    if (update_existing(env_list, key, vals))
        return (0);
    if (prepend_node(env_list, key, vals))
    {
        free(key);
        ft_free_string_array(vals);
        return (1);
    }
    return (0);
}

int builtin_export(t_exec *context)
{
    int i;
    int err;

    if (!context->argv[1])
        return (0);
    i = 1;
    err = 0;
    while (context->argv[i])
    {
        if (add_or_update(&context->env, context->argv[i]))
            err = 1;
        i++;
    }
    return (err);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   unset.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc < adi-marc@student.42luxembour    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:35:48 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/09 16:17:48 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

static void remove_env_entry(t_envi **env_list, char *name)
{
    t_envi  *curr;

    curr = *env_list;
    while(curr)
    {
        if (ft_strcmp(curr->env->key, name) == 0)
        {
            if (curr->prev)
                curr->prev->next = curr->next;
            else
                *env_list = curr->next;
            if (curr->next)
                curr->next->prev = curr->prev;
            free(curr->env->key);
            ft_free_string_array(curr->env->values);
            free(curr->env);
            free(curr);
            return ;
        }
        curr = curr->next;
    }
}

int	builtin_unset(t_exec *context)
{
	int	i;
	int	status;

	i = 1;
	status = 0;
	while (context->argv[i])
	{
		if (context->argv[i][0] == '\0'
			|| (!ft_isalpha(context->argv[i][0])
				&& context->argv[i][0] != '_'))
		{
			ft_printf("minishell: unset: `%s': not a valid identifier\n",
				context->argv[i]);
			status = 1;
		}
		else
			remove_env_entry(&context->env, context->argv[i]);
		i++;
	}
	return (status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc <adi-marc@student.42luxembourg    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:15:52 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/08 17:16:13 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

int  is_valid_name(const char *name)
{
    int i;

    if (!name || (!ft_isalpha(name[0]) && name[0] != '_'))
        return (0);
    i = 1;
    while (name[i])
    {
        if (!ft_isalnum(name[i]) && name[i] != '_')
            return (0);
        i++;
    }
    return (1);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   echo.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc <adi-marc@student.42luxembourg    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:00:50 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/08 17:04:20 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

int builtin_echo(t_exec *context)
{
    int i;
    int nflag;
    ssize_t w;

    i = 1;
    nflag = 0;
    while(context->argv[i] && ft_strcmp(context->argv[i], "-n") == 0)
    {
        nflag = 1;
        i++;
    }
    while(context->argv[i])
    {
        w = write(STDOUT_FILENO, context->argv[i], ft_strlen(context->argv[i]));
        if (w < 0)
            return (1);
        if (context->argv[i + 1])
            write(STDOUT_FILENO, " ", 1);
        i++;
    }
    if (!nflag)
        write(STDOUT_FILENO, "\n", 1);
    return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ituriel <ituriel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:45:55 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/17 18:10:53 by ituriel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

static int	is_numeric(const char *s)
{
	if (*s == '+' || *s == '-')
		s++;
	if (!*s)
		return (0);
	while (*s)
	{
		if (!ft_isdigit(*s))
			return (0);
		s++;
	}
	return (1);
}

int	builtin_exit(t_exec *context, t_memory **shell)
{
	int	argc;
	long	code;

	argc = 0;
	while (context->argv[argc])
		argc++;
	write(STDOUT_FILENO, "exit\n", 5);
	if (argc > 2)
	{
		ft_printf("minishell: exit: too many arguments\n");
		ft_free_shell(shell);
		exit(1);
	}
	if (argc == 2)
	{
		if (!is_numeric(context->argv[1]))
		{
			ft_printf("minishell: exit: %s: numeric argument required\n",
				context->argv[1]);
			ft_free_shell(shell);
			exit(2);
		}
		code = ft_atol(context->argv[1]) & 0xFF;
	}
	else
		code = context->status & 0xFF;
	ft_free_shell(shell);
	exit(code);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc <adi-marc@student.42luxembourg    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:06:43 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/08 18:45:23 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

int builtin_env(t_exec *context)
{
    t_envi  *node;
    size_t  i;

    node = context->env;
    while (node)
    {
        if (node->env->key && node->env->values)
        {
            ft_printf("%s=", node->env->key);
            i = 0;
            while (node->env->values[i])
            {
                ft_printf("%s", node->env->values[i]);
                if (node->env->values[i + 1])
                    ft_printf(":");
                i++;
            }
            ft_printf("\n");
        }
        node = node->next;
    }
    return (0);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd_utils.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc < adi-marc@student.42luxembour    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/10 10:36:16 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/10 10:39:07 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

static char **alloc_values(char *value)
{
    char **vals;

    vals = malloc(sizeof(*vals) * 2);
    if (!vals)
        return (NULL);
    vals[0] = ft_strdup(value);
    if (!vals[0])
    {
        free(vals);
        return (NULL);
    }
    vals[1] = NULL;
    return (vals);
}

static t_envp *create_entry(char *key, char **vals)
{
    t_envp *entry;

    entry = malloc(sizeof(*entry));
    if (!entry)
        return (NULL);
    entry->key = ft_strdup(key);
    if (!entry->key)
    {
        free(entry);
        return (NULL);
    }
    entry->values = vals;
    return (entry);
}

static t_envi *create_node(t_envi **env_list, t_envp *entry)
{
    t_envi *node;

    node = malloc(sizeof(*node));
    if (!node)
        return (NULL);
    node->env = entry;
    node->prev = NULL;
    node->next = *env_list;
    if (*env_list)
        (*env_list)->prev = node;
    *env_list = node;
    return (node);
}

int cd_add_env(t_envi **env_list, char *key, char *value)
{
    char   **vals;
    t_envp *entry;
    t_envi *node;

    vals = alloc_values(value);
    if (!vals)
        return (1);
    entry = create_entry(key, vals);
    if (!entry)
    {
        ft_free_string_array(vals);
        return (1);
    }
    node = create_node(env_list, entry);
    if (!node)
    {
        free(entry->key);
        ft_free_string_array(vals);
        free(entry);
        return (1);
    }
    return (0);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd.c                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc < adi-marc@student.42luxembour    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 16:43:03 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/10 10:39:17 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

static char	*get_env_value(t_envi *env_list, char *key)
{
	t_envi	*current;

	current = env_list;
	while (current)
	{
		if (!ft_strcmp(current->env->key, key)
			&& current->env->values && current->env->values[0])
			return (current->env->values[0]);
		current = current->next;
	}
	return (NULL);
}

static int	set_env_value(t_envi *env_list, char *key, char *value)
{
	t_envi	*current;
	char	**new_vals;

	current = env_list;
	while (current)
	{
		if (!ft_strcmp(current->env->key, key))
		{
			ft_free_string_array(current->env->values);
			new_vals = malloc(sizeof(*new_vals) * 2);
			if (!new_vals)
				return (1);
			new_vals[0] = ft_strdup(value);
			new_vals[1] = NULL;
			current->env->values = new_vals;
			return (0);
		}
		current = current->next;
	}
	return (1);
}

static char	*determine_target(const char *arg, t_envi *env_list, char **oldpwd_ptr)
{
	char	*home;

	if (!arg || arg[0] == '\0')
	{
		home = get_env_value(env_list, "HOME");
		return (home);
	}
	if (arg[0] == '-' && arg[1] == '\0')
	{
		*oldpwd_ptr = get_env_value(env_list, "OLDPWD");
		if (!*oldpwd_ptr)
			return ((char *)-1);
		ft_printf("%s\n", *oldpwd_ptr);
		return (*oldpwd_ptr);
	}
	return ((char *)arg);
}

static void	update_pwd_env(t_envi **env_list, char *oldpwd)
{
	char	*cwd;

	if (oldpwd)
	{
		if (set_env_value(*env_list, "OLDPWD", oldpwd))
			cd_add_env(env_list, "OLDPWD", oldpwd);
	}
	cwd = getcwd(NULL, 0);
	if (cwd)
	{
		if (set_env_value(*env_list, "PWD", cwd))
			cd_add_env(env_list, "PWD", cwd);
		free(cwd);
	}
}

int	builtin_cd(t_exec *context)
{
	char	*arg;
	char	*oldpwd;
	char	*target;
	int		ret;

	arg = context->argv[1];
	oldpwd = get_env_value(context->env, "PWD");
	target = determine_target(arg, context->env, &oldpwd);
	if (!target)
	{
		ft_printf("minishell: cd: HOME not set\n");
		return (1);
	}
	if (target == (char *)-1)
	{
		ft_printf("minishell: cd: OLDPWD not set\n");
		return (1);
	}
	ret = chdir(target);
	if (ret < 0)
	{
		ft_printf("minishell: cd: %s: %s\n", target, strerror(errno));
		return (1);
	}
	update_pwd_env(&context->env, oldpwd);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pwd.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adi-marc <adi-marc@student.42luxembourg    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:43:26 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/08 17:45:06 by adi-marc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

int builtin_pwd(t_exec *context)
{
    char    *cwd;

    (void)context;
    cwd = getcwd(NULL, 0);
    if (!cwd)
    {
        print_error("pwd: could not retrieve current directory\n");
        return (1);
    }
    ft_printf("%s\n", cwd);
    free(cwd);
    return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_env.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ituriel <ituriel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 14:38:04 by adi-marc          #+#    #+#             */
/*   Updated: 2025/07/17 18:37:16 by ituriel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

// Create a t_envp from a string "KEY=VALUE:VAL2:VAL3"
static t_envp   *envp_create(char *entry)
{
    t_envp  *node;
    char    *sep;

    sep = ft_strchr(entry, '=');
    if (!sep)
        return (NULL);
    node = malloc(sizeof(*node));
    if (!node)
        return(NULL);
    node->key = ft_mini_strndup(entry, sep - entry);
    if (!node->key)
    {
        free(node);
        return (NULL);
    }
    node->values = ft_split(sep + 1, ':');
    if (!node->values)
    {
        free(node->key);
        free(node);
        return (NULL);
    }
    return (node);
}

void shell_envi_init(t_memory **shell, char **envp)
{
    *shell = malloc(sizeof(t_memory));
    ft_memset(*shell, 0, sizeof(t_memory));
    env_init(&(*shell)->envi, envp);
}

// Initialize the env list
void    env_init(t_envi **shell, char **envp)
{
    t_envi  *head;
    t_envi  *current;
    t_envp  *entry;
    int i;

    head = NULL;
    i = 0;
    while (envp[i])
    {
        entry = envp_create(envp[i]);
        if (entry)
        {
            current = malloc(sizeof(*current));
            if(!current)
                break ;
            current->env = entry;
            current->prev = NULL;
            current->next = head;
            if (head)
                head->prev = current;
            head = current;
        }
        i++;
    }
    *shell = head;
}

// Destroy the entire env list
void    env_destroy(t_envi *shell)
{
    t_envi  *tmp;

    while(shell)
    {
        tmp = shell->next;
        free(shell->env->key);
        ft_free_string_array(shell->env->values);
        free(shell->env);
        free(shell);
        shell = tmp;
    }
}
