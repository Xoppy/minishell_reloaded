#!/usr/bin/expect -f
# test_interactive.exp — comprehensive Minishell tests with 0.5s sleeps

set timeout 5
spawn ./minishell

# Arrays to record test names and pass/fail status
set test_names  {}
set test_status {}

proc record_test {name passed} {
    global test_names test_status
    lappend test_names  $name
    lappend test_status $passed
}

# Sends a command, checks its output (regex) and exit code
proc run_and_record {name cmd outpat code} {
    expect "minishell$ "
    send -- "$cmd\r"
    after 500

    set passed 1
    if {[catch {expect -re $outpat}]} {
        set passed 0
    }

    expect "minishell$ "
    send -- "echo __EXIT__$?\r"
    after 500
    if {[catch {expect "__EXIT__$code"}]} {
        set passed 0
    }

    record_test $name $passed
}

# Grab environment values
set orig_pwd $env(PWD)
set home     $env(HOME)

# 1) echo hello
run_and_record "echo hello"              {echo hello}              {hello\r\n}        0

# 2) echo -n no_nl
run_and_record "echo -n no_nl"           {echo -n no_nl}           {no_nl$}          0

# 3) literal quotes
run_and_record "literal quotes"          {echo 'literal \$HOME'}   {literal \$HOME\r\n} 0

# 4) double-quote expand
run_and_record "double-quote expand"     "echo expand $home"       "expand $home\r\n" 0

# 5) export & echo
run_and_record "export TESTVAR"          {export TESTVAR=foo}      {}                 0
run_and_record "echo TESTVAR"            {echo $TESTVAR}           {foo\r\n}          0

# 6) unset & echo
run_and_record "unset TESTVAR"           {unset TESTVAR}           {}                 0
run_and_record "echo TESTVAR unset"      {echo $TESTVAR}           {\r\n}             0

# 7) false & $?
run_and_record "false cmd"               {false}                   {}                 1
run_and_record "echo status"             {echo \$\?}               {1\r\n}            0

# 8) env PATH
run_and_record "env PATH"                {env | grep '^PATH='}     {PATH=.*}          0

# 9) cd & pwd
run_and_record "pwd orig"                {pwd}                     "$orig_pwd\r\n"    0
run_and_record "cd /"                    {cd /}                    {}                 0
run_and_record "pwd /"                   {pwd}                     {/\r\n}            0
run_and_record "cd -"                    {cd -}                    "$orig_pwd\r\n"    0
run_and_record "cd bad"                  {cd no_such_dir}          {No such file or directory} 1
run_and_record "pwd after bad cd"        {pwd}                     "$orig_pwd\r\n"    0

#10) command not found
run_and_record "cmd not found"           {foobarcmd}               {command not found} 127

#11) invalid export/unset
run_and_record "export invalid"          {export 1BAD=val}         {not a valid identifier} 1
run_and_record "unset invalid"           {unset 1BAD}              {not a valid identifier} 1

#12) simple pipeline
run_and_record "pipeline wc"             {echo one two three | wc -w} {3\r\n}      0

#13) basic redirections
run_and_record "redir >"                 {echo out > tmp.txt}      {}                  0
run_and_record "cat tmp.txt"             {cat tmp.txt}             {out\r\n}         0
run_and_record "redir >>"                {echo more >> tmp.txt}    {}                  0
run_and_record "cat tmp.txt append"      {cat tmp.txt}             {more\r\n}        0
run_and_record "redir <"                 {wc -l < tmp.txt}         {\s*2\r\n}        0
run_and_record "cat < nofile"            {cat < nofile}            {No such file or directory} 1

#14) here-document expansion
expect "minishell$ "
send -- "cat <<EOF\r"
after 500
expect "> "
send -- "Y$home\r"
after 500
expect "> "
send -- "EOF\r"
after 500
set passed 1
if {[catch {expect "Y$home\r\n"}]} {
    set passed 0
}
expect "minishell$ "
send -- "echo __EXIT__$?\r"
after 500
if {[catch {expect "__EXIT__0"}]} {
    set passed 0
}
record_test "heredoc expansion" $passed

#15) pure pipe
run_and_record "pipe count"              {printf "x\ny\n" | wc -l} {2\r\n}      0

#16) Ctrl-C exit code
expect "minishell$ "
send   "\003"
after 500
set passed 1
expect "minishell$ "
send -- "echo __EXIT__$?\r"
after 500
if {[catch {expect "__EXIT__130"}]} {
    set passed 0
}
record_test "Ctrl-C exit code" $passed

#17) SIGQUIT ignore
expect "minishell$ "
send   "\034"
after 500
send -- "echo SIGQUIT_OK\r"
after 500
set passed 1
if {[catch {expect "SIGQUIT_OK"}]} {
    set passed 0
}
record_test "SIGQUIT ignore" $passed

#18) multi-stage pipeline
run_and_record "pipeline word→byte"      {echo foo bar | wc -w | wc -c} {2\r\n} 0

#19) here-doc → pipe
expect "minishell$ "
send   "grep bar <<EOF | wc -l\r"
after 500
expect "> "
send -- "foo\nbar\nbaz\n"
after 500
expect "> "
send -- "EOF\r"
after 500
set passed 1
if {[catch {expect "1\r\n"}]} {
    set passed 0
}
expect "minishell$ "
send -- "echo __EXIT__$?\r"
after 500
if {[catch {expect "__EXIT__0"}]} {
    set passed 0
}
record_test "heredoc→pipe" $passed

#20) combined < and >
run_and_record "in→out redir"            {cat < tmp.txt > tmp2.txt} {}      0
run_and_record "verify tmp2"             {cat tmp2.txt}             {out\r\n} 0

#21) pipeline with final redirection
run_and_record "pipe→file"               {echo one two | grep two > grep.txt} {} 0
run_and_record "verify grep.txt"         {cat grep.txt}             {two\r\n} 0

#22) built-in in pipeline
run_and_record "echo→echo"               {echo X | echo Y}          {Y\r\n}   0

#23) quoted pipe character
run_and_record "quoted pipe"             {echo "1 | 2" | wc -c}     {6\r\n}   0

#24) nested redir+pipe
run_and_record "wc←heredoc"              {wc -l < tmp.txt | wc -w}  {1\r\n}   0

#25) exit too many args
expect "minishell$ "
send   "exit 1 2\r"
after 500
set passed 1
if {[catch {expect -re "exit: too many arguments"}]} {
    set passed 0
}
expect "minishell$ "
record_test "exit too many args" $passed

#26) exit non-numeric — final
expect "minishell$ "
send   "exit abc\r"
after 500
set passed 1
if {[catch {expect -re "exit: abc: numeric argument required"}]} {
    set passed 0
}
record_test "exit non-numeric" $passed

# Print summary with escaped brackets
puts "\nTest Summary:"
set count [llength $test_names]
for {set i 0} {$i < $count} {incr i} {
    set name   [lindex $test_names  $i]
    set status [lindex $test_status $i]
    if {$status} {
        puts "\[Y\] $name"
    } else {
        puts "\[X\] $name"
    }
}

# Exit 1 if any test failed
if {[lsearch -all $test_status 0] >= 0} {
    exit 1
} else {
    exit 0
}